/dts-v1/;

/ {   
	#size-cells = <0x2>;
	#address-cells = <0x2>;

	cpus {
		#size-cells = <0x0>;
		#address-cells = <0x1>;

		cpu@0 {
			compatible = "arm,armv8";
			device_type = "cpu";
			enable-method = "psci";
			reg = <0x0>;
		};

	};

	psci {
		compatible = "arm,psci-0.2";
		method = "smc";
	};


	memory@80000000 {
		reg = <0x0 0x80000000 0x0 0x20000000>;
		device_type = "memory";
	};

	gic: intc@8000000 {
		interrupts = <0x01 0x09 0x04>;
		reg = <0x00 0x51a00000 0x00 0x10000 0x00 0x51b00000 0x00 0xf60000>;
		#redistributor-regions = <0x01>;
		compatible = "arm,gic-v3";
		interrupt-controller;
		#interrupt-cells = <0x03>;
        interrupt-parent = <&gic>;
	};

   	timer {
		compatible = "arm,armv8-timer";
		interrupt-parent = <&gic>;
		interrupts = <0x1 0xd 0xf08 0x1 0xe 0xf08 0x1 0xb 0xf08 0x1 0xa 0xf08>;
	};

	xtal32k: clock-xtal32k {
		compatible = "fixed-clock";
		#clock-cells = <0>;
		clock-frequency = <32768>;
		clock-output-names = "xtal_32KHz";
	};

	xtal24m: clock-xtal24m {
		compatible = "fixed-clock";
		#clock-cells = <0>;
		clock-frequency = <24000000>;
		clock-output-names = "xtal_24MHz";
	};

	dma_ipg_clk: clock-dma-ipg {
		compatible = "fixed-clock";
		#clock-cells = <0>;
		clock-frequency = <120000000>;
		clock-output-names = "dma_ipg_clk";
	};

	/**
	 * We are assigning a mu to the linux guest because the linux drivers 
	 * assume linux can directly interact with the SCU to configure its devices.
	 * Therefore, this guest will be able to configure peripherals not assigned
	 * to it. In the future we will have to either to move the cores 
	 * belonging to this guest to a separate scfw partition or paravirtualise 
	 * the MU1 and interpose the guest's communcation to the SCU, to limit 
	 * which resource it might configure.
	 */ 
	lsio_mu1: mailbox@5d1c0000 {
		compatible = "fsl,imx8qm-mu", "fsl,imx6sx-mu";
		reg = <0x0 0x5d1c0000 0x0 0x10000>;
		interrupt-parent = <&gic>;
		interrupts = <0 177 4>;
		#mbox-cells = <2>;
		status = "okay";
	};

	scu {
		compatible = "fsl,imx-scu";

		mbox-names = "tx0", "tx1", "tx2", "tx3",
			     "rx0", "rx1", "rx2", "rx3",
			     "gip3";

		mboxes = <&lsio_mu1 0 0
			  &lsio_mu1 0 1
			  &lsio_mu1 0 2
			  &lsio_mu1 0 3
			  &lsio_mu1 1 0
			  &lsio_mu1 1 1
			  &lsio_mu1 1 2
			  &lsio_mu1 1 3
			  &lsio_mu1 3 3>;

		pd: imx8qx-pd {
			compatible = "fsl,imx8qm-scu-pd", "fsl,scu-pd";
			#power-domain-cells = <1>;
		};

		clk: clock-controller {
			compatible = "fsl,imx8qm-clk", "fsl,scu-clk";
			#clock-cells = <2>;
			clocks = <&xtal32k &xtal24m>;
			clock-names = "xtal_32KHz", "xtal_24Mhz";
		};
	};

	edma0: dma-controller@5a2c0000 {
		compatible = "fsl,imx8qm-edma";
		reg = <0x0 0x5a2c0000 0x0 0x10000>, /* channel12 UART0 rx */
		      <0x0 0x5a2d0000 0x0 0x10000>; /* channel13 UART0 tx */
		#dma-cells = <3>;
		dma-channels = <2>;
		interrupts = <0 434 4>, <0 435 4>;
		interrupt-parent = <&gic>;
		interrupt-names = "edma0-chan12-rx", "edma0-chan13-tx";
		power-domains =   <&pd 76>, <&pd 77>; /* lpuart0 */
		power-domain-names = "edma0-chan12", "edma0-chan13";
		status = "okay";
	};

	uart0_lpcg: clock-controller@5a460000 {
		compatible = "fsl,imx8qxp-lpcg";
		reg = <0x0 0x5a460000 0x0 0x10000>;
		#clock-cells = <1>;
		clocks = <&clk 57 2>,
			 <&dma_ipg_clk>;
		bit-offset = <0 16>;
		clock-output-names = "uart0_lpcg_baud_clk",
				     "uart0_lpcg_ipg_clk";
		power-domains = <&pd 57>;
	};

	lpuart0: serial@5a060000 {
		compatible = "fsl,imx8qm-lpuart", "fsl,imx8qxp-lpuart";
		reg = <0x0 0x5a060000 0x0 0x1000>;
        interrupt-parent = <&gic>;
        interrupts = <0 345 4>;
		clocks = <&uart0_lpcg 1>, <&uart0_lpcg 0>;
		clock-names = "ipg", "baud";
		assigned-clocks = <&clk 57 2>;
		assigned-clock-rates = <80000000>;
		power-domains = <&pd 57>;
		power-domain-names = "uart";
		dmas = <&edma0 13 0 0>, <&edma0 12 0 1>;
		dma-names = "tx","rx";
	    status = "okay";
	};

    bao-ipc@60000000 {
        compatible = "bao,pseudo-ivshmem-net";
        #address-cells = <2>;
        #size-cells = <2>;
        reg = <0x0 0x60000000 0x0 0x00010000>;
        interrupt-parent = <&gic>;
        interrupts = <0x0 152 0x4 0x0 153 0x4>;
        id = <0>;
    };

	aliases {
		serial0 = &lpuart0;
	};

	chosen {
		bootargs = "clk_ignore_unused ip=192.168.42.15 carrier_timeout=0";
		stdout-path = &lpuart0;
	};
};
